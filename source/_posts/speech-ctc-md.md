---
title: CTC原理解析
toc_nav_num: true
catalog: true
date: 2019-07-09 16:19:54
subtitle: 连接时序分类CTC
header-img:
tags: 语音识别
mathjax: true
---

# CTC简介(Connectionist Temporal Classfication)
连接时序分类，适合不知道输入输出是否对其的情况使用的算法，所以CTC适合语音识别和手写字符识别的任务。

## CTC原理
我们定义如下，输入用符号序列X=[x1,x2,...xT], Y=[y1,y2,...yU],为了方便训练这些数据我闷希望能够找到输入X和输出Y之间的映射关系。

## 损失函数定义
对于给定的输入X，我们训练模型希望最大化Y的后验概率P(Y|X)，P(Y|X)应该是可导的，这样就能利用梯度下降训练模型了。

## 对齐存在的问题
![](/img/article/ctc_duiqi.png)
- 通常这种对齐方式是不合理的，比如在语音识别任务中，有些音频可能是无声的，这时候应该是没有字符输出的
- 对于一些本应含有重复字符的输出，这种对齐方式没法得到准确的输出。例如输出对齐的结果为[h, h, e, l, l, l, o],通过去重操作后得到的不是“hello”而是“helo”

## 解决方法
- 为了解决上述问题，CTC算法引入一个新的占位符用于输出对齐结果。这个占位符称为空白占位符，通常使用符号$$\epsilon$$,这个符号在对齐结果中输出，但是在最后的去重操作将会所有的$$\epsilon$$删除得到最终的输出。利用这个占位符，可以将输入与输出有了非常合理的对应关系。
![](/img/article/ctc_duiqi2.png)
- 在这个映射方式中，如果在标定文本中有重复的字符，对齐过程中会在两个重复的字符当中插入$$\epsilon$$占位符。利用这个规则，上面的“hello”就不会变成“helo”了。
![](/img/article/ctc_duiqi3.png)

## 损失函数
1. CTC对齐输入输出是多对一的。多条路径最后的输出都是hello，要讲所有的路径相加才是输出的条件概率。
1. 对于一对输入输出(X,Y)来说，CTC的目标是将下式概率最大化。
$$
p(Y | X)=\sum_{A \in \mathcal{A}_{X, Y}} \prod_{t=1}^{T} p_{t}\left(a_{t} | X\right)
$$
乘法表示一条路径的所有字符概率相乘，加法表示多条路径。
1. 对于一个输出，路径会非常多，这样直接计算概率是不现实的，CTC算法采用动态规划的思想来求解输出的条件概率。
![](/img/article/ctc_method.png)

# 动态规划求解最大后验概率方法
![](/img/article/ctc_dynamic_p.png)
- $$\alpha$$表示对齐结果合并后节点的概率，
- 如图所示可以采用动态规划求解该类问题。

## Case1:
1. 如果$$\alpha_{s, t}=\epsilon$$，则$$\alpha_{s, t}$$只能由前一个字符$$\alpha_{s-1, t-1}$$或者本身$$
\alpha_{s, t-1}$$得到
2. 如果$$\alpha_{s, t}$$不等于$$\epsilon$$,且$$\alpha_{s, t}$$为连续字符的第二个(上面第二个o)，则$$\alpha_{s, t}$$只能由一个空白符$$\alpha_{s-1, t-1}$$或者其本身$$\alpha_{s, t-1}$$得到，而不能由前一个字符得到。
- 上述两种情况中，$$\alpha_{s, t}$$可由下式算出，其中$$p_{t}\left(z_{s} | X\right)$$表示在时刻t输出字符$$z_{s}$$的概率。
$$
\alpha_{s, t}=(\alpha(s, t-1)+\alpha(s-1, t-1)) \cdot p_{t}\left(z_{s} | X\right)
$$

## Case2:
1. 如果$$\alpha_{s, t}$$不等于$$\epsilon$$，则可由$$\alpha_{s-2, t-1}, \alpha_{s-1, t-1}, \alpha_{s, t-1}$$得来。
$$
\alpha_{s, t}=(\alpha(s, t-1)+\alpha(s-1, t-1)+\alpha(s-2, t-1)) \cdot p_{t}\left(z_{s} | X\right)
$$

## 总结
上图中输出两个终止点，最后输出的条件概率为两个终止点输出的概率之和，使用这种方法就能高效的计算损失函数。
模型的目标就是最小化负对数似然函数
$$
\sum_{(X, Y) \in \mathcal{D}}-\log p(Y | X)
$$

# CTC解码函数
## ctc_greedy_decoder
- 采用贪婪算法进行解码
1. 即直接算出每个时刻取概率最大的字符作为输出。
1. 通常这种算法很有效，但是忽略了一个输出可能对应对个对齐结果。例如[a,a,null]和[a,a,a]各自概率均小于[b,b,b]，该算法得到的结果为Y=[b],但是结果为Y=[a]更为合理。

## ctc_beam_search_decoder
- 采用集束搜索算法
1. 该算法有个参数为width，假设宽度为3，在RNN输出中，该算法每个时间t输出时。不同于贪婪算法只找最高的，而是找最高的三个概率作为下一次的输入，依次迭代。(当width=1时，则就变成贪婪算法)。
